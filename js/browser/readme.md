Gecko webkit
# DOM树
字节数据 --> 字符串 --> 标记(Token)
标记完成之后，这些标记会紧接着转换为Node, 不同的Node会根据之前的联系构建一棵DOM树

# CSSOM树
过程类似于DOM树的产生，但是更加消耗性能，因为样式可以是自行设定的，也可能是继承获得的。
在这个过程中，浏览器需要递归CSSOM树才能确定具体的元素到底是什么样式
（对于css 应该避免使用具体的css选择器 会加大浏览器的性能消耗 优化点）
（对于html 应该尽量少使用无意义的标签）

# 渲染树
DOM树 + CSSOM树 = render树
渲染树不是简单的将两者合并，渲染树只会包括**需要显示的节点**和这些节点的样式信息，比如： display: none 的节点就不会在渲染树中显示

当浏览器生成渲染树之后，就会根据渲染树来进行布局(回流)，然后GPU绘制

# 为什么操作DOM慢
因为DOM树归渲染引擎操作，js归js引擎操作，当使用js直接操作dom时，涉及到两个线程之间的通信，势必带来性能损耗

# 什么情况下会阻塞渲染
渲染的前提是有渲染树 html和css会影响到渲染的时间
html尽可能扁平化 优化css选择器 可以在一定程度上让渲染变快

当浏览器读到script标签时会停止渲染，因为js是单线程的

## 当要往页面中插入上万个DOM结构时，如何实现不卡顿？
1. 利用 requestAnimationFrame 循环插入DOM结构
2. 可以做虚拟滚动/虚拟DOM结构