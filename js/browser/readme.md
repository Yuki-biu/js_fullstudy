Gecko webkit
# DOM树
字节数据 --> 字符串 --> 标记(Token)
标记完成之后，这些标记会紧接着转换为Node, 不同的Node会根据之前的联系构建一棵DOM树

# CSSOM树
过程类似于DOM树的产生，但是更加消耗性能，因为样式可以是自行设定的，也可能是继承获得的。
在这个过程中，浏览器需要递归CSSOM树才能确定具体的元素到底是什么样式
（对于css 应该避免使用具体的css选择器 会加大浏览器的性能消耗 优化点）
（对于html 应该尽量少使用无意义的标签）

# 渲染树
DOM树 + CSSOM树 = render树
渲染树不是简单的将两者合并，渲染树只会包括**需要显示的节点**和这些节点的样式信息，比如： display: none 的节点就不会在渲染树中显示

当浏览器生成渲染树之后，就会根据渲染树来进行布局(回流)，然后GPU绘制

# 为什么操作DOM慢
因为DOM树归渲染引擎操作，js归js引擎操作，当使用js直接操作dom时，涉及到两个线程之间的通信，势必带来性能损耗

# 什么情况下会阻塞渲染
渲染的前提是有渲染树 html和css会影响到渲染的时间
html尽可能扁平化 优化css选择器 可以在一定程度上让渲染变快

当浏览器读到script标签时会停止渲染，因为js是单线程的

## 当要往页面中插入上万个DOM结构时，如何实现不卡顿？
1. 利用 requestAnimationFrame 循环插入DOM结构
2. 可以做虚拟滚动/虚拟DOM结构


# 回流(Reflow) && 重绘(Repaint)
计算渲染树中每一个节点在设备视口的确切位置和大小，这个计算阶段就叫做回流
拿到渲染树中节点的几何信息后，将节点转换为屏幕上的实际像素，这个阶段叫做重绘节点


# 何时发生回流重绘

**回流一定重绘 重绘不一定回流**
- 发生回流：
    1. 删除或添加**可见**的DOM元素
    2. 元素的位置发生变化
    3. 元素的尺寸发生变化（宽高、边框大小、内外边距）
    4. 内容变化（文本变化、替换不同尺寸的图片）
    5. 页面初次渲染
    6. 浏览器窗口的尺寸发生变化

# 浏览器的优化机制
目前大多数浏览器都会通过队列化修改批量的回流过程，浏览器会修改操作放到队列里，直到一段时间后或者到达阈值，才会一次性全部重绘，清空队列。
但是，获取布局信息的操作会强制队列刷新。
offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
getComputedStyle()
getBoundingClientRect

# 减少回流重绘
- 修改单一DOM：
    1. cssText
    2. 使用类名

- 批量修改DOM：
    1. 使元素脱离文档流，对其进行多次修改，将元素带回文档流中

- 脱离文档流的方式：
    1. 隐藏元素
    2. 使用文档片段构建子DOM树
    3. 将原始元素拷贝到脱离文档的节点中，修改后再替换原始元素


[demo](https://juejin.im/post/6844903779700047885)
